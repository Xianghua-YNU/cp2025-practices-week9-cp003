# 盒计数法估算分形维数实验报告

## 一、实验目的

1. 理解分形维数（特别是盒维数）的概念和数学原理
2. 掌握盒计数(Box Counting)算法的实现方法
3. 通过编程计算给定分形图像的维数
4. 分析不同参数对计算结果的影响

## 二、实验过程

### 1. 核心算法实现

**图像加载与二值化:**
- 使用Pillow/PIL库读取图像
- 设定阈值进行二值化处理
- 转换为NumPy数组
```python
  def load_and_binarize_image(image_path, threshold=128):  
    img = Image.open(image_path).convert('L')  # 灰度化  
    img_array = np.array(img)  
    binary_image = (img_array > threshold).astype(int)  # 阈值分割，前景为1，背景为0  
    return binary_image
```
**盒计数算法实现:**
```python
def box_count(binary_image, box_sizes):  
    height, width = binary_image.shape  
    counts = {}  
    for box_size in box_sizes:  
        rows = height // box_size  
        cols = width // box_size  
        count = 0  
        for i in range(rows):  
            for j in range(cols):  
                box = binary_image[i*box_size:(i+1)*box_size, j*box_size:(j+1)*box_size]  
                if np.any(box == 1):  # 检查是否包含前景像素  
                    count += 1  
        counts[box_size] = count  
    return counts  
```
数据处理与线性回归:

- 计算log(ε)和log(N(ε))
- 使用numpy.polyfit进行线性拟合
- 计算分形维数 D = -slope
### 2. 实验参数
![barnsley](https://github.com/user-attachments/assets/cce054be-731d-4073-9736-6762c507c50a)
- 盒子尺寸：生成等比数列 \(\epsilon = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\)，共 11 个尺寸
- 阈值：128

### 3. 遇到的问题与解决
- 问题：初始代码中图像路径错误导致 FileNotFoundError。
- 解决：手动确认图像实际存储路径（E:\计算物理\barnsley.png），修正路径格式（Windows 系统使用双反斜杠转义）。
- 问题：若图像前景为深色（灰度值低），默认阈值 128 会导致前景像素漏判。
- 解决：通过可视化二值化结果，调整阈值为 64（或根据图像实际明暗程度动态优化）。
- 问题：当盒子尺寸大于图像边长时导致索引错误。
- 解决：将最大盒子尺寸设为图像最小边长（max_box_size = min(image.shape)），确保网格划分合法。
## 三、结果展示
### 1. 盒计数结果
![image](https://github.com/user-attachments/assets/62d31b5f-bb2e-4d3a-bd57-764ca33dfdee)


关键数据:


以下是单独输出的盒计数关键数据表格：


| 盒子尺寸 \( \epsilon \) | 盒子数量 \( N(\epsilon) \) | \( \log \epsilon \) | \( \log N(\epsilon) \) |
|---------------------|-----------------------|-------------------|-----------------------|
| 1                   | 3209892               | 0.0000            | 14.9817               |
| 2                   | 809815                | 0.6931            | 13.6046               |
| 4                   | 206410                | 1.3863            | 12.2376               |
| 8                   | 53746                 | 2.0794            | 10.8920               |
| 16                  | 14034                 | 2.7726            | 9.5492                |
| 32                  | 3565                  | 3.4657            | 8.1789                |
| 64                  | 870                   | 4.1589            | 6.7685                |
| 128                 | 210                   | 4.8520            | 5.3471                |
| 256                 | 49                    | 5.5452            | 3.8918                |
| 512                 | 9                     | 6.2383            | 2.1972                |
| 1024                | 1                     | 6.9315            | 0.0000                |
- 拟合斜率: [-2.0912]
- 计算得分形维数D: [\(D = 2.0912\)]
### 2. 与理论值比较
- 理论分形维数: [ 1.62]
- 计算误差分析: [(0.4712/1.62)×100%≈29.1%]
## 四、分析与思考
1. 算法准确性分析
   
   - 盒子尺寸选择对结果的影响:
   - 尺寸应覆盖多个数量级（如从图像边长的 \(1/2\) 到 1），避免集中在单一范围导致拟合偏差。等比数列（如每次尺寸减半）能均匀采样对数空间，提升线性拟合精度。
   - 图像分辨率对计算精度的影响:
   - 高分辨率图像（如 \(2048 \times 2048\)）可支持更小的盒子尺寸，捕捉更多细节，减少离散化误差。低分辨率图像在小盒子尺寸下可能丢失分形细节，导致 \(N(\epsilon)\) 计数不足。
2. 误差来源分析
   
   - 边界处理的影响:
   - 图像边缘的盒子可能未完全填充（如边长不能整除时忽略剩余像素），导致边缘区域盒子漏判。
改进方法：对图像进行边缘填充（补零），确保盒子尺寸严格整除边长。
   - 线性拟合的合理性评估:
   - 当 \(\epsilon\) 过大或过小时，数据点可能偏离理想幂律关系（如 \(\epsilon=1\) 时计数包含噪声），需排除异常点（如 \(\epsilon=1024\) 和 \(\epsilon=1\)）后重新拟合。
3. 扩展思考
   
   - 如何改进算法提高计算精度:
   - 使用可变阈值（如 Otsu 算法）自动确定二值化阈值，避免手动调参误差。
对每个盒子进行 “部分覆盖” 加权计数（而非简单的存在性判断），更接近理论盒计数定义。
   - 三维分形维数的计算方法:
   - 三维分形维数计算可使用立方体盒子，统计覆盖三维点云的最小立方体数量，对数关系为 \(\log N(\epsilon) \propto -D \log \epsilon\)。
   - 与其他维数计算方法的比较:
   - 与豪斯多夫维数相比，盒维数计算更简单，但对噪声和边界更敏感；两者在理想分形上结果一致，但实际应用中盒维数更常用。
4. 算法优化
   
   - 计算效率优化方案:
   - 使用向量化操作（如 scipy.ndimage.measurements.block_reduce）替代双重循环，提升盒子统计速度。
   - 并行计算的可能性:
   - 对不同盒子尺寸并行处理，利用多核 CPU 加速批量计数。

**注：请在每一部分补充您的实验内容、图像、分析和关键代码。**
